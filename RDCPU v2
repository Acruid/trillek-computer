NOTE: WIP. Need to check that are any opcodes clash

License : CC BY-SA 3.0 http://creativecommons.org/licenses/by-sa/3.0/

Risc Dumb CPU Specification
Version 0.3 

=== SUMMARY ====================================================================

 * 16 bit RISC CPU, can access 0x10000 octects of ram (0x0000 to 0xFFFF)
 * 13 general purpose registers (R1 to R13)
 * Multiplication register Y
 * Base Pointer (BP)
 * Stack Pointer (SP)
 * Flags Register (FLAGS)
 * Interrupt Address (IA)

In this document, anything within [brackets] is shorthand for "the value of the
RAM at the location of the value inside the brackets". For example, SP means
stack pointer, but [SP] means the value of the RAM at the location the stack
pointer is pointing at.

Whenever the CPU needs to read a word, it reads [PC], then increases PC by two.
Shorthand for this is [PC+2]. In some cases, the CPU will modify a value before
reading it, in this case the shorthand is [++X].

The RDCPU instruction set is based in 16 bit words, so each time that the PC is
incremented, is incremented by two.

For stability and to reduce bugs, it's strongly suggested all multi-word
operations use little endian in all RCPU programs, wherever possible.


20 Registers :
  - R0 - Reads always 0 value
  - R1 .. R13 - General Purpose Registers
  - R14 - BP - Base Pointer -> Acts like a GPR 
  - R15 - SP - Stack Pointer -> Points to the last value Pushed
  - FLAGS register
  - Y - Multiplication/Division register
  - IA - Interrupt Address
  - PC - Program Counter  

FLAGS register :
  BIT 15-4 -> Unused (read always 0)
  BIT 3 -> OVERFLOW FLAG 1 if signed arithmetic operation overflowed
  BIT 2 -> CARRY FLAG 1 if the last ADDx/SUBx carried or borrowed a bit
  BIT 1 -> DIVISION ERROR FLAG 1 if was a division error.
  BIT 0 -> INTERRUPT FLAG 1 if interrupts is rised


=== BOOT/RESET STATUS ==========================================================

All registers are set to 0 when the RDCPU bootup or does a reset


=== INSTRUCTIONS ===============================================================

Note: 4 bit Literals are defined from 0 to 30. 31 Literal (1111) is reserved to
      mark that the next word is a 16 bit Literal value.

Instructions with 3 parameters :

15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
-----------------------------------------------
 1  x  x  x r1 r1 r1 r1 r2 r2 r2 r2 r3 r3 r3 r3

LOAD    [REG1 + LITERAL], REG3        1000 RRRR LLLL RRRR
LOAD    [REG1 + REG2], REG3           1001 RRRR RRRR RRRR
LOAD.B  [REG1 + LITERAL], REG3        1010 RRRR LLLL RRRR
LOAD.B  [REG1 + REG2], REG3           1011 RRRR RRRR RRRR
STORE   [REG1 + LITERAL], REG3        1100 RRRR LLLL RRRR
STORE   [REG1 + REG2], REG3           1101 RRRR RRRR RRRR
STORE.B [REG1 + LITERAL], REG3        1110 RRRR LLLL RRRR
STORE.B [REG1 + REG2], REG3           1111 RRRR RRRR RRRR

Instructions with 2 parameters :

15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
-----------------------------------------------
 0  1  x  x  x  x  x  x r2 r2 r2 r2 r3 r3 r3 r3

ADD     REG3 op REG2 -> REG3          0100 0000 RRRR RRRR
ADD     REG3 op LITERAL -> REG3       0100 0001 LLLL RRRR
SUB     REG3 op REG2 -> REG3          0100 0010 RRRR RRRR
SUB     REG3 op LITERAL -> REG3       0100 0011 LLLL RRRR
ADDC    REG3 op REG2 -> REG3          0100 0100 RRRR RRRR
SUBC    REG3 op REG2 -> REG3          0100 0101 RRRR RRRR
SUBC    REG3 op LITERAL -> REG3       0100 0110 LLLL RRRR

AND     REG3 op REG2 -> REG3          0100 0111 RRRR RRRR
OR      REG3 op REG2 -> REG3          0100 1000 RRRR RRRR
XOR     REG3 op REG2 -> REG3          0100 1001 RRRR RRRR

SLL     REG3 op REG2 -> REG3          0100 1010 RRRR RRRR
SLL     REG3 op LITERAL -> REG3       0100 1011 LLLL RRRR
SRL     REG3 op REG2 -> REG3          0100 1100 RRRR RRRR
SRL     REG3 op LITERAL -> REG3       0100 1101 LLLL RRRR
SRA     REG3 op REG2 -> REG3          0100 1110 RRRR RRRR
SRA     REG3 op LITERAL -> REG3       0100 1111 LLLL RRRR

ROTL    REG3 op REG2 -> REG3          0101 0000 RRRR RRRR
ROTL    REG3 op LITERAL -> REG3       0101 0001 LLLL RRRR
ROTR    REG3 op REG2 -> REG3          0101 0010 RRRR RRRR
ROTR    REG3 op LITERAL -> REG3       0101 0011 LLLL RRRR

MUL     REG3 op REG2-> REG3           0101 0100 RRRR RRRR
MUL     REG3 op LITERAL-> REG3        0101 0101 LLLL RRRR
DIV     REG3 op REG2-> REG3           0101 0110 RRRR RRRR
DIV     REG3 op LITERAL-> REG3        0101 0111 LLLL RRRR

SWP     REG2, REG3                    0101 1000 RRRR RRRR

CPY     REG2 -> REG3                  0101 1001 RRRR RRRR
SET     LITERAL -> REG3               0101 1010 LLLL RRRR

BEQ     REG2 op REG3                  0101 1011 RRRR RRRR
BEQ     LITERAL op REG3               0101 1101 LLLL RRRR
BNEQ    REG2 op REG3                  0101 1111 RRRR RRRR
BNEQ    LITERAL op REG3               0110 0000 LLLL RRRR
BG      REG2 op REG3                  0110 0001 RRRR RRRR
BG      LITERAL op REG3               0110 0010 LLLL RRRR
BGE     REG2 op REG3                  0110 0011 RRRR RRRR
BGE     LITERAL op REG3               0110 0100 LLLL RRRR
BUG     REG2 op REG3                  0110 0101 RRRR RRRR
BUG     LITERAL op REG3               0110 0110 LLLL RRRR
BUGE    REG2 op REG3                  0110 0111 RRRR RRRR
BUGE    LITERAL op REG3               0110 1000 LLLL RRRR
BBITS   REG2 op REG3                  0101 0010 RRRR RRRR
BCLEAR  REG2 op REG3                  0101 0011 RRRR RRRR

INP     REG2 op REG3                  0101 0100 RRRR RRRR
INP     LITERAL op REG3               0101 0101 LLLL RRRR
OUT     REG2 op REG3                  0101 0110 RRRR RRRR
OUT     LITERAL op REG3               0101 0111 LLLL RRRR

JMP (Absolute)  to [REG3 + LITERAL]   0111 1110 LLLL RRRR
CALL (Absolute) to [REG3 + LITERAL]   0111 1111 LLLL RRRR

Instructions with 1 parameter :

15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
-----------------------------------------------
 0  0  1  x  x  x  x  x  x  x  x  x r3 r3 r3 r3

NOT      REG3                         0010 0000 0000 RRRR
NEG      REG3                         0010 0000 0001 RRRR

XCHG     REG3                         0010 0000 0010 RRRR
SXTBD    REG3                         0010 0000 0011 RRRR

PUSH     REG3                         0010 0000 0100 RRRR
POP      REG3                         0010 0000 0101 RRRR

GETPC    REG3                         0010 0000 0110 RRRR
GETFLAGS REG3                         0010 0000 0111 RRRR

SETY     REG3                         0010 0000 0111 RRRR
SETY     LITERAL                      0010 0000 1000 RRRR
GETY     REG3                         0010 0000 1001 RRRR

INT     REG3                          0010 0000 1010 RRRR
INT     LITERAL                       0010 0000 1011 LLLL
GETIA   REG3                          0010 0000 1100 RRRR
SETIA   REG3                          0010 0000 1101 RRRR
SETIA   LITERAL                       0010 0000 1111 LLLL

reserved REG3                         0011 xxxx xxxx RRRR


Instructions with 1 parameter and long literal (-256 to 255) :

15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
-----------------------------------------------
 0  0  0  1  x  x  x  L  L  L  L  L  L  L  L  L

JMP (Relative)  to [LITERAL + PC]     0001 001L LLLL LLLL
CALL (Relative) to [LITERAL + PC]     0001 010L LLLL LLLL


Instructions 0 parameters :

15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00
-----------------------------------------------
 0  0  0  0  x  x  x  x  x  x  x  x  x  x  x  x

NOP                                   0000 0000 0000 0000
SLEEP                                 0000 0000 0000 0001

RET                                   0000 0000 0000 0010
RFI                                   0000 0000 0000 0011

CLRDIVERR                             0000 0000 0000 0100

BOVF                                  0000 0000 0000 1000
BOCF                                  0000 0000 0000 1001

reserved                              1xxx xxxx xxxx xxxx



=== DESCRIPTION OF INSTRUCTIONS ===============================================
  
=== RAM INSTRUCTIONS ==========================================================
  
  LOAD [REG1 + REG2], REG3
  LOAD [REG1 + LITERAL], REG3
  
  Load a value from RAM at REG1 + REG2 values or REG1 + Literal value, and put
  it in REG3.
  LOAD.B only reads LSB BYTE from RAM and put it on LSB of REG3
  
  
  STORE [REG1 + REG2], REG3
  STORE [REG1 + LITERAL], REG3
  
  Write REG3 value in RAM at REG1 + REG2 values or REG1 + Literal value.
  STORE.B only writes on LSB BYTE from the LSB of REG3
  
  
=== ALU OPERATIONS =============================================================
  
  ADD REG3, REG2
  ADD REG3, LITERAL
  
  Do the addition of REG3 + REG2 (or LITERAL) and put it on REG3.
  
  
  ADDC REG3, REG2
  
  Do the addition of REG3 + REG2 with Carry Bit and put it on REG3
  
  
  SUB REG3, REG2
  SUB REG3, LITERAL
  
  Do the subtraction of REG3 - REG2 (or LITERAL) and put it on REG3.
  
  
  SUBC REG3, REG2
  SUBC REG3, LITERAL

  Do the subtraction of REG3 - REG2 (or LITERAL) with Carry Bit and put it on
  REG3. 
  

  MUL REG3, REG2
  MUL REG3, LITERAL

  Do the 16x16 bit multiplication of Reg3 x Reg2 (or literal).
  Stores the 16 bit most significant bits in the Y register. The lowest
  significant 16 bit are stored in Reg3


  DIV REG3, REG2
  DIV REG3, LITERAL

  Do the 32/16 bit multiplication of Y:Reg3 / Reg2 (or literal).
  Uses the value of Y register as the 16 most significant bits of the dividend
  and Reg3 as the 16 lowest significant bits.
  The quotient are stores in Y:Reg3, where the Y register stores the 16 bit most
  significant bits and the Reg3 stores the 16 bit less significant bits.
  If a division error happens, the RDCPU will throw a exception with message 0, 
  and will be set Division Error flag to 1

  NOT REG3

  Apply NOT logic operation over Reg3 value and writes on Reg3


  NEG REG3
  
  Does the two complement of REG3 and put it on REG3. (Converts a positive number
  to a negative )
  

  AND REG3, REG2
  
  Do the logic AND operation between REG3 and REG2 and put it to REG3.
  
  
  OR REG3, REG2
  
  Do the logic OR operation between REG3 and REG2 and put it to REG3.
  
  
  XOR REG3, REG2
  
  Do the logic XOR operation between REG3 and REG2 and put it to REG3.
  
  
  SLL REG3, REG2
  
  Do the Logic Left Shift of REG3, displacing value of REG2 bits and put it to 
  REG3. The output bit are stores in Carry Flag.

  
  SRL REG3, REG2
  
  Do the Logic Right Shift of REG3, displacing value of REG2 bits and put it to 
  REG3. The output bit are stores in Carry Flag.

  
  SRA REG3, REG2
  
  Do the Arithmetic Right Shift of REG3, displacing value of REG2 bits and put it
  to REG3. The output bit are stores in Carry Flag. 

  
  ROTL REG3, REG2
  
  Do the Left Rotation of REG3, displacing value of REG2 bits and put it to
  REG3. 

  
  ROTL REG3, REG2
  
  Do the Right Rotation of REG3, displacing value of REG2 bits and put it to 
  REG3. 
  
=== BRANCHING OPERATIONS =======================================================

  The conditional opcodes take one cycle longer to perform if the test fails.
  When they skip a conditional instruction, they will skip an additional
  instruction at the cost of one extra cycle. This continues until a non-
  conditional instruction has been skipped. This lets you easily chain
  conditionals. Interrupts are not triggered while the RDCPU is skipping.
  
  
  BEQ REG3, REG2       Branch On Equal
  BEQ REG3, LITERAL    "
  BNEQ REG3, REG2      Branch On NOT Equal
  BNEQ REG3, LITERAL   "
  BG REG3, REG2        Branch if Reg3 > Reg2 (signed ints)
  BG REG3, LITERAL     "
  BGE REG3, REG2       Branch if Reg3 >= Reg2 (signed ints)
  BGE REG3, LITERAL    "
  BUG REG3, REG2       Branch if Reg3 > Reg2 (unsigned ints)
  BUG REG3, LITERAL    "
  BUGE REG3, REG2      Branch if Reg3 >= Reg2 (unsigned ints)
  BUGE REG3, LITERAL   "

  BBITS REG3, REG2     Branch if Reg3 & Reg2 != 0 (bitwise AND operation)
  BCLEAR REG3, REG2    Branch if Reg3 & Reg2 == 0

  BOVF                 Branch if Overflow FLAG is setted ( == 1 )
  BOCF                 Branch if Carry FLAG is setted ( == 1 )

=== REGISTER OPERATIONS ========================================================

  SWP REG3, REG2       Swaps Reg3 and Reg2 values
  CPY REG3, REG2       Copy the value of Reg2 to Reg3
  SET REG3, LITERAL    Puts a literal value on Reg3
  
  XCHG REG3            Swaps LSB and MSB bytes of Reg3
  SXTBD REG3           Extends LSB byte of Reg3 to fill Reg3 and keeps the sign

=== JUMP INSTRUCTIONS =========================================================
  Jump Instructions:

  JMP [REG3 + LITERAL] Jumps to Reg3 + literal. Absolute Address
  JMP [LITERAL]        Jumps to PC + 9 bit literal (-256 to 255). 
                       Relative Address.
  CALL [REG3+ LITERAL] Jumps to Reg3 + literal and Push PC to the stack. 
                       Absolute Address.
  CALL [LITERAL]       Jumps to PC + 9 bit literal (-256 to 255) and Push PC to
                       the stack. Relative Address.
  RET                  Pops a value from stack and sets PC to these value. 
                       (Return from CALL)

=== STACK INSTRUCTIONS ========================================================

  PUSH REG3            Writes Reg3 value at [--SP], aka Push Reg3 to the stack
  POP REG3             Reads at [SP++] and put to Reg3, aka Pop stack into Reg3

=== SPECIAL INSTRUCTIONS ======================================================

  NOP                  Not Operation (Do nothing)
  SLEEP                Sleeps the CPU and wakes when an hardware interrupt is 
                       triggered
  GETPC REG3           Puts PC+2 value in Reg3
  GETFLAGS REG3        Puts FLAGS value in Reg3

  SETY REG3            Sets Y register value
  SETY LITERAL         "
  GETY REG3            Puts Y register value in Reg3

  CLRDIVERR            Clears Division Error Flag
 
=== INTERRUPT INSTRUCTIONS ====================================================

  INT REG3
  INT LITERAL          
  Triggers a software interrupt with message of REG3 or 4 bit Literal.


  GETIA REG3           Sets REG3 to IA value
  SETIA REG3           Sets IA to REG3 value
  SETIA LITERAL        "

  RFI                  Return from interrupt

=== HARDWARE INTERFACE INSTRUCTIONS ===========================================
INP REG3, REG2         Reads Reg2 IO address and write the value to Reg3
INP REG3, LITERAL      "

OUT REG3, REG2         Writes Reg2 IO address the value of Reg3
OUT REG3, LITERAL      "
  
  

=== INTERRUPTS =================================================================    

The RDCPU uses what is know how interrupt polling handling scheme. There not is 
a vector table, instead there is only a interrupt vector were the OS installs a 
ISR, that polls FLAGS register and/or reads R1 register to discover what kind of
interrupt happen and who launch it.

When the RDCPU have IA register set to a value != 0, then the interrupts are
enabled. Interrupts can be generated by software by INT instruction or by 
hardware getting to Low the INT line. An interrupt is processed when the RDCPU 
is ready to process a new instruction. When an interrupt is being processed, the
IACQ line goes to high indicating that the RDCPU will ignore the INT line or any
software interrupt This means that all instructions are atomic.

When a Interrupt happens, the RDCPU push to the stack, the values of PC and R1
register, jumps to IA address, and sets the INTERRUPT FLAG to 1. If it's a 
software interrupt, the message is put on R1 to be processed. If it's a hardware
interrupt, sets R1 to value read in the data bus.

When the interrupt service routine ends, executing a RFI, the RDCPU pops R1
register, sets IACK (Interrupt Acknowledge) line to Low, and
push the stack to set the old value of PC.


=== INTERRUPT LIST =============================================================

The first 256 (0-255) interrupt messages are reserved for software interrupts,
that a OS can define what will do. 
The rest could be used by hardware devices and the devices specs should clarify 
what interrupt message uses, if throws any interrupt.

If a division error happens, the RDCPU will throw a exception with message 0.


=== HARDWARE ===================================================================    

The RDCPU have a separate IO address space of 8 bit that can be accessed using
INP and OUT instructions.


=== EXAMPLE MEMORY MAP =========================================================

The memory map is defined by the OS and computer architecture, but here we give
a example memory map:

0xFFFF |---------|
       |  STACK  |
0xDFFF |---------|
       |         |
       |         |
       |Available|
       |         |
       |         |
0x5000 |---------|
       |  Video  |
       |   RAM   |
0x4000 |---------|
       |   BOOT  |
       |   ROM   |
0x0000 |---------|

It uses a 4KiB video ram to represent a text only video mode, and uses a ROM that
sets the hardware and launch user code from a floppy



=== ANNEX ======================================================================

The actual specs, only can address to 64KiB of RAM directly, needing a external 
device to do bank switching or MMU. I have some  ideas to add segment registers 
and extend address space much more. The idea is add four special registers :
- CS : Code Segment
- DS : Data Segment
- SS : Stack Segment
- IS : Interrupt Segment

This registers are read like 16 bit registers, but only can be written the low 4
bits. The  higher bits always are read to be 0.
The idea is that the the RDCPU uses 20 bit address using the segment register 
as most significant bits. So the RDCPU reads a instruction at [CS:PC]; does 
load/store at [DS:xxxx]; operates over the stack at [SS:SP]; and jumps on a 
interrupt to the address [IS:IA]. So the segments have a fixed size of 64KiB, 
and not overlap like in the x86 real mode. The good point is that is more 
flexible and can be expanded to handle huge address spaces, using more bits.
A side effect is that the DCPU must handle load/store with the BP and SP 
registers using the Stack segment instead of Data Segment, to peek and use stack
variables and arguments. The other is add instructions to set and read the value
 of these registers
